import pandas as pd
import plotly.express as px
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from dash import Dash, dcc, html, Input, Output
import dash_bootstrap_components as dbc
import os

# === 1. Carregar base ===
arquivo = 'C:\\Users\\guilherme.lopes\\OneDrive - Cadiveu\\Área de Trabalho\\base_vendas_24.xlsx'
df = pd.read_excel(arquivo, sheet_name='Base vendas')

# === 2. Limpeza ===
df.columns = df.columns.str.strip()
df['Emissao'] = pd.to_datetime(df['Emissao'], errors='coerce')
df = df.dropna(subset=['Emissao', 'Cliente', 'Produto', 'Quantidade'])
df['AnoMes'] = df['Emissao'].dt.to_period('M').dt.to_timestamp()
df['Cliente'] = df['Cliente'].astype(str)
df['Produto'] = df['Produto'].astype(str)

# === 3. Filtrar apenas vendas de 2024 em diante ===
df = df[df['AnoMes'] >= '2024-01-01']

# === 4. Agrupar dados ===
agrupado = df.groupby(['Cliente', 'Produto', 'AnoMes'])['Quantidade'].sum().reset_index()

# === 5. Função de previsão ===
def prever(cliente, produto):
    dados = agrupado[(agrupado['Cliente'] == cliente) & (agrupado['Produto'] == produto)].copy()
    dados = dados.sort_values('AnoMes')

    if len(dados) < 6:
        return pd.DataFrame(), "Dados insuficientes para previsão."

    serie = dados.set_index('AnoMes')['Quantidade']
    
    # Corrigir o índice para ter frequência mensal regular
    serie.index = pd.date_range(start=serie.index.min(), periods=len(serie), freq='MS')

    try:
        modelo = ExponentialSmoothing(serie, trend='add', seasonal=None, initialization_method='estimated')
        ajuste = modelo.fit()
        previsao = ajuste.forecast(12).round().astype(int)
    except Exception as e:
        return pd.DataFrame(), f"Erro ao ajustar o modelo: {str(e)}"

    previsao = previsao.reset_index()
    previsao.columns = ['AnoMes', 'Quantidade']
    previsao['Cliente'] = cliente
    previsao['Produto'] = produto
    previsao['Previsao'] = 'Previsão'

    dados['Previsao'] = 'Histórico'
    dados = dados.rename(columns={'AnoMes': 'AnoMes', 'Quantidade': 'Quantidade'})

    df_plot = pd.concat([dados, previsao], ignore_index=True)
    return df_plot, None

# === 6. App Dash ===
app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

clientes = sorted(agrupado['Cliente'].unique())
produtos_por_cliente = agrupado.groupby('Cliente')['Produto'].unique().apply(list).to_dict()

app.layout = dbc.Container([
    html.H2("Painel de Vendas e Previsão"),
    dbc.Row([
        dbc.Col([
            html.Label("Cliente:"),
            dcc.Dropdown(id='dropdown-cliente', options=[{'label': c, 'value': c} for c in clientes], value=clientes[0])
        ], width=6),
        dbc.Col([
            html.Label("Produto:"),
            dcc.Dropdown(id='dropdown-produto')
        ], width=6)
    ]),
    html.Br(),
    dcc.Graph(id='grafico-vendas'),
    html.Div(id='mensagem-erro', style={'color': 'red'})
])

@app.callback(
    Output('dropdown-produto', 'options'),
    Output('dropdown-produto', 'value'),
    Input('dropdown-cliente', 'value')
)
def atualizar_produtos(cliente):
    produtos = produtos_por_cliente.get(cliente, [])
    return [{'label': p, 'value': p} for p in produtos], produtos[0] if produtos else None

@app.callback(
    Output('grafico-vendas', 'figure'),
    Output('mensagem-erro', 'children'),
    Input('dropdown-cliente', 'value'),
    Input('dropdown-produto', 'value')
)
def atualizar_grafico(cliente, produto):
    df_plot, erro = prever(cliente, produto)
    if erro:
        return px.line(title="Erro"), erro
    fig = px.line(df_plot, x='AnoMes', y='Quantidade', color='Previsao', title=f"{cliente} - {produto}", markers=True)
    fig.update_layout(xaxis_title='Mês', yaxis_title='Quantidade Vendida')
    return fig, None

# === 7. Executar o app ===
import os

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 8050))
    app.run(host='0.0.0.0', port=port)
